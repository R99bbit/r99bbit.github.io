

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>Security Research</title>
  <subtitle></subtitle>
  <updated>2023-03-04T17:32:12+09:00</updated>
  <author>
    <name>Park Min</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator>
  <rights> © 2023 Park Min </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>[iOS] iOS-Encrypted 된 IPA 복호화하기</title>
    <link href="http://localhost:4000/posts/ios-ipa-dump-frida/" rel="alternate" type="text/html" title="[iOS] iOS-Encrypted 된 IPA 복호화하기" />
    <published>2023-03-04T01:03:00+09:00</published>
  
    <updated>2023-03-04T01:03:00+09:00</updated>
  
    <id>http://localhost:4000/posts/ios-ipa-dump-frida/</id>
    <content src="http://localhost:4000/posts/ios-ipa-dump-frida/" />
    <author>
      <name>Park Min</name>
    </author>

  
    
    <category term="MOBILE" />
    
    <category term="IOS" />
    
  

  
    <summary>
      





      Why?

  최근 맡은 프로젝트에서 iOS 애플리케이션을 분석할 일이 생겼다. 점점 하다보니 왜 애플이 자기네들 제품/솔루션에 어마어마한 바운티를 걸었는지 알 것 같다. 그냥 간단한 애플리케이션 추출 과정도 번거롭고 번거롭다… iOS 애플리케이션 패키지인 IPA는 안드로이드 APK와 다르게 바로 추출한 파일을 Decompile 했을 때 분석을 할 수 없게 Instruction 들을 뭉개놓았다. 이를 해체하는 작업을 해보자.




그냥 추출하면?



  아쉽게도 탈옥 없이, 덤프 없이, 복호화 없이는 위와 같이 다 뭉개진 바이너리를 던져주는 것을 알 수 있다.
  애초에 IDA에서 “이건 iOS Encrypted 되어있는데 갠춘?” 이라고 물어본다.
  frida를 이용해서 복호화 된 IPA를 덤프...
    </summary>
  

  </entry>

  
  <entry>
    <title>[iOS] iPhone에 Frida 환경 세팅하기</title>
    <link href="http://localhost:4000/posts/ios-setting-frida/" rel="alternate" type="text/html" title="[iOS] iPhone에 Frida 환경 세팅하기" />
    <published>2023-03-04T01:02:00+09:00</published>
  
    <updated>2023-03-04T01:02:00+09:00</updated>
  
    <id>http://localhost:4000/posts/ios-setting-frida/</id>
    <content src="http://localhost:4000/posts/ios-setting-frida/" />
    <author>
      <name>Park Min</name>
    </author>

  
    
    <category term="MOBILE" />
    
    <category term="IOS" />
    
  

  
    <summary>
      





      Why?

  최근 맡은 프로젝트에서 iOS 애플리케이션을 분석할 일이 생겼다. 우열곡절 iOS 탈옥을 완료했고, 이제 frida를 세팅해보려고 한다.




분석 환경 구성하기

0. iPhone 탈옥하기

  아무래도 frida를 사용하려면 탈옥, 루팅이 필요할 것이다. 바로 이전 글에서 iOS 탈옥에 대해 다뤘으니 선행하도록 하자.


1. MacBook에 frida-tools 설치하기



  터미널을 열고 pip3 install frida-tools 으로 frida-tools를 설치한다. 이는 frida-ps, frida-trace 등 유용한 도구들을 포함한다.


2. iPhone에 frida 설치하기


  iPhone이 탈옥되어 있다면 Cydia, Sileo 등 탈옥된 기기의 패키지 관리...
    </summary>
  

  </entry>

  
  <entry>
    <title>[iOS] iOS 16.3.1 Jailbreak (on MacOS)</title>
    <link href="http://localhost:4000/posts/ios-jailbreak-16/" rel="alternate" type="text/html" title="[iOS] iOS 16.3.1 Jailbreak (on MacOS)" />
    <published>2023-03-04T01:01:00+09:00</published>
  
    <updated>2023-03-04T01:01:00+09:00</updated>
  
    <id>http://localhost:4000/posts/ios-jailbreak-16/</id>
    <content src="http://localhost:4000/posts/ios-jailbreak-16/" />
    <author>
      <name>Park Min</name>
    </author>

  
    
    <category term="MOBILE" />
    
    <category term="IOS" />
    
  

  
    <summary>
      





      Why?

  최근 맡은 프로젝트에서 iOS 애플리케이션을 분석할 일이 생겼다. APK의 경우 대충 시중에 널려있는 에뮬레이터 가져다가 (어차피 루팅 손쉽게 할 수 있으니깐 버튼 하나로) frida 설치하고 후킹 돌리면서 분석하면 되는데 iOS는 그렇게 간단한 문제가 아니더라. 대충 번개장터에서 아무 휴대폰이나 사서 다운그레이드 한 다음에 탈옥시키면 되는줄 알았다. 그런데 막상 중고로 산 핸드폰은 최신 업데이트 되어있었고, Sign 없는 버전은 설치 안되는 문제 등등 이리저리 치이다가 그냥 가장 최신인 iOS 16.3 에서 탈옥하는 방법을 택했다.




내 기기도 가능할까?

개발자에 의하면 A8 부터 A11 칩셋을 사용하는 모델까지 가능하다고 한다. 호환되는 기기 목록은 아래와 같다.

  iPho...
    </summary>
  

  </entry>

  
  <entry>
    <title>[Docker] Nginx를 이용해서 SSL 설정하기(HTTPS)</title>
    <link href="http://localhost:4000/posts/docker-nginx-proxy-ssl/" rel="alternate" type="text/html" title="[Docker] Nginx를 이용해서 SSL 설정하기(HTTPS)" />
    <published>2023-02-01T00:56:01+09:00</published>
  
    <updated>2023-02-01T00:56:01+09:00</updated>
  
    <id>http://localhost:4000/posts/docker-nginx-proxy-ssl/</id>
    <content src="http://localhost:4000/posts/docker-nginx-proxy-ssl/" />
    <author>
      <name>Park Min</name>
    </author>

  
    
    <category term="DOCKER" />
    
  

  
    <summary>
      





      Why?

  최근에 브라우저와 내 서버 간의 HTTP 통신을 다뤄야 하는 일이 있었다. 이 때 브라우저로 접속한 서버는 HTTPS, 내가 구현한 서버는 HTTP 였기 때문에 당연하게도 Mixed Contents 문제가 발생했다. 문제를 해결하기 위해 내 서버에 SSL 인증을 넣어주기로 했다. 서버에 SSL 인증을 받는 방법에는 여러가지가 있지만, 매번 프레임워크 별 HTTPS 적용 방법을 검색하는 것이 지쳤기 때문에 항상 눈독들여 왔던 “nginx reverse proxy로 ssl 인증 적용하기(무려 docker로!)” 를 시도해보려고 한다.



  +) 금방 구현할 수 있을 줄 알았는데 생각보다 많은 시간이 걸렸다. 관련 글들은 많으나 어딘가 난잡했고, 여기저기서 config 내용을 복붙하다보니 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>[Dreamhack CTF Season 2 #11] Welcome writeup</title>
    <link href="http://localhost:4000/posts/dreamhack-welcome/" rel="alternate" type="text/html" title="[Dreamhack CTF Season 2 #11] Welcome writeup" />
    <published>2023-01-29T21:56:00+09:00</published>
  
    <updated>2023-01-29T23:05:34+09:00</updated>
  
    <id>http://localhost:4000/posts/dreamhack-welcome/</id>
    <content src="http://localhost:4000/posts/dreamhack-welcome/" />
    <author>
      <name>Park Min</name>
    </author>

  
    
    <category term="CTF" />
    
    <category term="PWNABLE" />
    
  

  
    <summary>
      





      source code
chal 바이너리의 내용은 아래와 같다.

int __cdecl main(int argc, const char **argv, const char **envp)
{
  __asm { endbr64 }
  sub_1080(1001LL, 1001LL, 1001LL);
  sub_1090("clear");
  sub_1070("Tada~!");
  return 0;
}


바이너리를 실행하면 clear를 실행하고 Tada~ 문자열을 출력한 뒤 종료한다. 이제 remote에 접속해보자

pwn@localhost:~$ id
uid=1000(pwn) gid=1000(pwn) groups=1000(pwn)
pwn@localhost:~$ ls -al
total 48
drwxr-x--- 1 pwn ...
    </summary>
  

  </entry>

</feed>


